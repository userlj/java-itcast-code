代码仅仅是思想的一种体现。

阶段文档：
一,
	面向对象：
	1，是一种思想。
	2，将复杂事情简单化。
	3，从执行者转到指挥者。

	程序中的体现：完成功能，或者实现项目。只要去找已有的对象即可。
			如果java中并没有提供相对应对象，这时就建立一个相关的对象即可。

	面向有三个特征：
	封装：隐藏实现细节，提高安全性。
	继承：提高了代码的复用性，让类与类之间产生了关系。
	多态：提高了代码的扩展性。


	类与对象关系：
	类：对事物的描述，定义类就是在定义事物成员(属性和行为)
	对象：就是该类事物实在存在的个体。


	类中的成员：
	1，构造函数：用于给对象进行初始化。
		对象一建立，就会调用对应的构造函数进行初始化。

	
	2，成员变量，成员函数：
		通常成员变量都需要私有化，通过对应的set，get方法来对其进行访问。
	

	代码示例：
	class Person
	{
		private String name;
		private int age;
		Person()
		{
			this("baby",0);
		}
		Person(String name)
		{
			this(name,0);
		}
		Person(String name,int age)
		{
			this.name = name;
			this.age = age;
		}

		public void setName(String name)
		{
			this.name = name;
		}
		public void setAge(int age)
		{
			this.age = age;
		}

		public String getName()
		{
			return name;
		}
		public int getAge()
		{
			return age;
		}
		
		public void speak()
		{
			System.out.println(this.name+"::"+this.age);
		}

	}
	注意：一个类中都需要定义什么样的功能，需要参照该事物所在问题领域而言。

	
	介绍两个关键字：
	this：代表本类对象的引用。
	static:被对象所共享，可以直接被类名调用。

	成员变量和类变量的区别：
	成员变量：示例变量，在对象创建时，存在与对象所属的堆内存中。每个对象都有一份。
	类变量：类加载的时候，加载到方法区中，所有对象都共享一份。

	
	继承：
	子父类中成员的特点：
	成员函数：
		当子父类中的出现一模一样的函数时，会出现一个操作---覆盖。
	构造函数：
		子类中所有的构造函数，都会默认访问父类中的空参数构造函数，因为子类中的构造
		函数的第一行都有一句隐式的super();
		因为子类要知道获取的父类成员在父类中是如何初始化的。

		当父类中没有空参数的构造函数时，子类的构造函数就必须通过super或者this语句指定要访问的构造函数。

	涉及到了一个关键字：super。
	super:代表的就是父类对象的引用。


	final：
	1，final修饰的类不可以被继承。
	2，final修饰的变量是一个常量，只能赋值一次。
	3，final修饰的方法不可以被覆盖。
	4，内部类在局部时，只能访问被final修饰的局部变量。
	5，final可以修饰类，可以修饰方法，可以修饰变量。

	
	抽象类：
	1，被abstract所修饰。
	2，抽象类不可以被实例化。
	3，抽象类中可以存在抽象方法。
	4，只有子类覆盖了所有的抽象方法后，子类才可以被实例化。

	abstract：
	不可以和哪些关键字共存呢？
	final，static，private。



	接口：interface。
	接口中定义的成员有固定的修饰符：
	成员常量：public static final
	成员函数：public abstract 

	接口的特点：
	1，接口用于功能的扩展。
	2，接口是对外提供的规则。
	3，接口降低了藕合性。
	4，接口支持多继承。
	5，接口的出现可以让类进行多现实。
	6，一类在继承一个类的同时，可以实现多个接口。


	
	多态：
	程序中的体现：
	父类或者接口的引用指向了子类对象。
	多态出现后：
	成员函数：
		Fu f = new Zi();
		f.show();
		编译看左边，运行看右边。

	
	
	PCI.的例子。

	interface　PCI
	{
		void  open();
	}
	class MainBoard
	{
		void run(){}
		void usePCI(PCI p)
		{
			p.open();
		}
	}

	main()
	{
		MainBoard mb = new MainBoard();
		mb.run();
		mb.usePCI(new NetCard());

	}

	class NetCard implements PCI
	{
		public void open(){}
	}


--------------------------------------------------

	内部类：
	描述事物的时候该事物内部还有事物，通过内部类的形式来完成。

	内部类可以直接访问外部类中的成员，因为内部类持有了外部类的引用：外部类名.this
	
	而外部类需要建立内部类对象才可以访问内部类中的成员。

	匿名内部类：
	就是内部类的简写格式。
	但是要有前提：
		内部类需要继承外部类或者实现外部接口。

	格式：new 类名或者接口(){}
	
	必须要明确：匿名内部类其实就是一个子类对象。


------------------------------------------------

	异常：
	在程序运行时出现的一些不正常情况。

	其实就是java按照面向对象的思想对问题进行对象的封装。

	建立体系：特点：该体系中的所有对象都具备可抛性，也就是可以被throws throw关键字所操作。
	Throwable
		|--Error：一般不编写针对代码进行处理，需要对程序源码进行修正。
		|--Exception：可以处理的。

	定义功能时，如果该功能，因为参数的原因，或者其他原因，会出现一些不正常情况，
	需要在函数上通过throws关键字进行标识。
	让调用者进行处理。

	处理的异常的两种方式：
	1，调用者继续throws抛出。
	2，通过try catch进行处理。

	原则一：功能出现多少个异常，那么try处理时，就对应多少个catch。


	功能内部如果有异常被throw抛出，那么函数上一定要声明(除非编译时异常外)。

	throw 和throws的区别：
	throw：用在函数内，后面跟的是异常对象。
	throws：用在函数上，后面跟的是异常类，可以跟多个，用逗号隔开。


	自定义异常：
	其实就是对特有的情况进行描述。
	定义一个类继承Exception，让该子类具备可抛性。
	如果想要自定义信息，可以通过构造函数的super语句。
	class MyException extends Exception
	{
		MyException(String message)
		{
			super(message);
		}
	}

	异常Exception：分编译时检查异常，运行时异常(RuntimeException)。

	如果在函数内通过throw抛出的是RuntimeException或者其子类对象，那么可以不用在函数上通过throws声明。

	那么我们在自定义异常时多一个选择，就是可以继承RuntimeException。


	finally:
	该代码块很重要，里面存放的是一定会被执行的代码，通常用于关闭资源(如：数据库连接)。

	只有执行到System.exit(0)时，finally也不会被执行。

	异常的好处：
	可以引起程序的跳转，可以将正常流程代码与问题处理代码相分离。

-----------------------------------------------------------------

	包：
	1，对类文件进行分类管理。
	2，给类提供了多层命名空间。

	一般定义包为了保证类的同名区别，所以包名要尽量保证唯一性。使用域名居多。

	包与包之间的访问，只有两种权限可用的：public protected(该权限只有不同包中的子类可以用)

	类的全名称：包名.类名。 
	为了简化类名的书写，使用一个关键字import.
	import:导入包的类。不导入包中的包。
	import pack.*;
	import pack.aa.*;








	


	


